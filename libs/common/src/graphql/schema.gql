# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type AcceptProposalResponse {
  contract: Contract!
  proposal: Proposal!
}

type Chat {
  conversations: [Message!]!
  createdAt: DateTime!
  id: ID!
  lastMessage: Message
  lastMessageId: String
  receiver: User
  receiverId: String
  sender: User
  senderId: String
  updatedAt: DateTime!
}

type ChatsResponse {
  entries: [Chat!]!
  total: Int!
}

type Connection {
  createdAt: DateTime!
  follower: User
  followerId: String
  following: User
  followingId: String
  id: ID!
  status: String!
  updatedAt: DateTime!
}

enum ConnectionStatus {
  ACCEPTED
  PENDING
  REJECTED
}

enum ConnectionType {
  FOLLOWER
  FOLLOWING
}

type ConnectionsResponse {
  entries: [Connection!]!
  total: Int!
}

type Contract {
  contractor: User
  contractorId: String!
  createdAt: DateTime!
  endDate: DateTime
  gig: Gig
  gigId: String!
  helper: User
  helperId: String!
  id: ID!
  proposal: Proposal
  proposalId: String!
  startDate: DateTime
  status: ContractStatus!
  updatedAt: DateTime!
}

enum ContractStatus {
  ACTIVE
  CANCELED
  COMPLETED
}

type ConversationsResponse {
  entries: [Message!]!
  total: Int!
}

input CreateChatInput {
  attachment: Upload
  message: String

  """Receiver ID (Optional)"""
  receiverId: ID
}

input CreateGigInput {
  budget: Float!

  """Mandatory Field"""
  deadline: DateTime!

  """Mandatory Field"""
  description: String!
  image: String
  jobType: String
  location: String
  paymentMethod: String
  requirements: String

  """Mandatory Field"""
  title: String!
}

input CreateUserInput {
  bio: String
  category: String
  company: String
  email: String!
  firstname: String!
  lastname: String!
  password: String!
  phone: String
  role: UserRole!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type Gig {
  budget: Float
  contractor: User!
  contractorId: String!
  createdAt: DateTime!
  description: String!
  id: ID!
  image: String
  jobType: String
  location: String
  maxProposal: Float
  noOfProposals: Float
  paymentMethod: String
  proposals: [Proposal!]!
  requirements: String
  startDate: DateTime
  status: String!
  title: String!
  updatedAt: DateTime!
}

type GigsResponse {
  entries: [Gig!]!
  total: Int!
}

type LoginResponse {
  accessToken: String!
  user: User!
}

type Message {
  chat: Chat
  chatId: String!
  createdAt: DateTime!
  id: ID!
  message: String
  seen: Boolean!
  sender: User
  senderId: String!
  updatedAt: DateTime!
}

type Mutation {
  acceptConnectionRequest(id: ID!): Connection!
  acceptProposal(id: ID!): AcceptProposalResponse!
  createGig(createGigInput: CreateGigInput!): Gig!
  deleteConnectionRequest(id: ID!): String!
  login(email: String!, password: String!): LoginResponse!
  register(payload: CreateUserInput!): RegistrationResponse!
  rejectProposal(id: ID!): Proposal!
  removeGig(id: String!): Gig!
  saveUnsaveGig(gigId: ID): ID
  sendConnectionRequest(followingId: ID!): Connection!
  sendMessage(payload: CreateChatInput!): Chat!
  sendProposal(payload: SendProposalInput!): Proposal!
  updateGig(updateGigInput: UpdateGigInput!): Gig!
  updateUser(payload: UpdateUserInput!): User!
}

type Proposal {
  coverLetter: String!
  createdAt: DateTime!
  gig: Gig
  gigId: String!
  helper: User
  helperId: String!
  id: ID!
  status: String!
  updatedAt: DateTime!
}

type ProposalsResponse {
  entries: [Proposal!]!
  total: Int!
}

type Query {
  chats(limit: Int, page: Int, searchText: String): ChatsResponse!
  connections(connectionType: ConnectionType, limit: Int, page: Int, searchText: String, status: ConnectionStatus): ConnectionsResponse!
  conversations(chatId: ID!, limit: Int, page: Int, searchText: String): ConversationsResponse!
  gig(id: ID!): Gig
  gigs(contractorId: String, limit: Int, page: Int, searchText: String): GigsResponse!
  myGigs(limit: Int, page: Int, searchText: String): GigsResponse!
  myProposals(limit: Int, page: Int, searchText: String): ProposalsResponse!
  proposals(gigId: ID!): [Proposal!]!
  savedGigs(limit: Int, page: Int, searchText: String): GigsResponse!
  user(id: ID!): User!
  users(limit: Int, page: Int, role: UserRole, searchText: String): UsersResponse!
}

type RegistrationResponse {
  message: String!
  user: User!
}

input SendProposalInput {
  """Mandatory Field"""
  coverLetter: String!

  """Mandatory Field"""
  gigId: String!
}

type Subscription {
  messageAdded(chatId: ID!): Message!
}

input UpdateGigInput {
  budget: Float

  """Mandatory Field"""
  deadline: DateTime

  """Mandatory Field"""
  description: String
  id: Int!
  image: String
  jobType: String
  location: String
  paymentMethod: String
  requirements: String

  """Mandatory Field"""
  title: String
}

input UpdateUserInput {
  bio: String
  category: String
  company: String
  email: String!
  firstname: String!
  lastname: String!
  phone: String
}

"""File upload scalar type"""
scalar Upload

type User {
  bio: String
  category: String
  company: String
  createdAt: DateTime!
  email: String!
  firstname: String
  id: ID!
  isEmailVerified: Boolean!
  lastname: String!
  location: String
  phone: String
  profilePicture: String
  role: UserRole!
  updatedAt: DateTime!
}

enum UserRole {
  ADMIN
  CONTRACTOR
  HELPER
}

type UsersResponse {
  entries: [User!]!
  total: Int!
}